# Лабораторная работа 4
## Структура проекта

### 1. `Money.cs` — Класс для работы с денежными величинами

Класс `Money` представляет собой модель денежной суммы, состоящей из рублей (`uint`) и копеек (`byte`). Он обеспечивает целостность данных и поддерживает основные арифметические операции.

#### Поддерживаемые операции:
*   **Унарные операции**:
    *   `++`: Увеличение суммы на 1 копейку.
    *   `--`: Уменьшение суммы на 1 копейку (с защитой от отрицательных значений).
*   **Бинарные операции**:
    *   `Money + Money`: Сложение двух сумм.
    *   `Money + uint` / `uint + Money`: Прибавление целого числа рублей к сумме.
    *   `Money - Money`: Разность двух сумм (результат 0, если вычитаемое больше).
    *   `Money - uint` / `uint - Money`: Вычитание рублей (с защитой от отрицательных значений).
*   **Приведение типов**:
    *   `explicit (uint)`: Возвращает количество рублей (целая часть).
    *   `implicit (double)`: Возвращает копейки в виде дробной части (например, `0.50` для 50 копеек).

---

### 2. `ListAndHash.cs` — Алгоритмы работы с коллекциями

Статический класс `ListAndHash` содержит реализацию алгоритмов для решения типовых задач с использованием коллекций (`List<T>`, `LinkedList<T>`, `HashSet<T>`).

#### Реализованные алгоритмы:

1.  **Вставка списка в самого себя (`InsertAfterElement`)**
    *   *Вход*: Список целых чисел и значение элемента `E`.
    *   *Действие*: Находит первое вхождение элемента `E` и вставляет после него копию всего исходного списка.
    *   *Используемая коллекция*: `List<int>`.

2.  **Модификация связного списка (`PrependAndAppend`)**
    *   *Вход*: Связный список (`LinkedList`) и число `E`.
    *   *Действие*: Добавляет число `E` в начало (`AddFirst`) и в конец (`AddLast`) списка.
    *   *Используемая коллекция*: `LinkedList<int>`.

3.  **Анализ читательских предпочтений (`AnalyzeBooks`)**
    *   *Вход*: Каталог книг и данные о прочитанных книгах от нескольких пользователей.
    *   *Действие*: Используя множества, определяет:
        *   Книги, прочитанные **всеми** читателями (пересечение множеств).
        *   Книги, прочитанные **некоторыми**, но не всеми (разность множеств).
        *   Книги, которые **никто** не читал.
    *   *Используемые коллекции*: `Dictionary<string, HashSet<string>>`, `HashSet<string>`.

4.  **Поиск уникальных символов в тексте (`FindSymbols`)**
    *   *Вход*: Текстовый файл.
    *   *Действие*: Находит символы, которые встречаются во всех словах текста, начиная со второго, но отсутствуют в первом слове.
    *   *Алгоритм*:
        1.  Разбиение текста на слова.
        2.  Формирование множества символов первого слова.
        3.  Поиск пересечения множеств символов всех остальных слов.
        4.  Исключение из найденного пересечения символов первого слова.
    *   *Используемые коллекции*: `HashSet<char>`, `List<string>`.

---

### Тестирование класса `Money`
Запустите программу и выберите соответствующие пункты меню:
1.  **Создание объекта**: Введите рубли и копейки. Проверьте корректность вывода `ToString()`.
2.  **Арифметика**: Попробуйте сложить два объекта или вычесть рубли. Убедитесь, что копейки корректно переполняются в рубли (например, 50 коп + 60 коп = 1 руб 10 коп).
3.  **Граничные случаи**: Попробуйте вычесть большую сумму из меньшей — результат должен быть `0 руб 0 коп`.

### Тестирование алгоритмов (`ListAndHash`)
Для работы этого раздела убедитесь, что в папке с исполняемым файлом находится текстовый файл `TextLab.txt` для теста №4.
1.  **Задание 1 & 2**: Вводите последовательности чисел через консоль.
2.  **Задание 3**: Введите количество читателей и названия книг. Программа выведет статистику на основе пересечения множеств.
3.  **Задание 4**: Программа автоматически проанализирует файл `TextLab.txt` и выведет найденные символы.


# Тестовые сценарии для проверки классов

В данном документе приведены конкретные тестовые кейсы (входные данные и ожидаемый результат) для проверки корректности работы классов `Money` и `ListAndHash`.

---

## 1. Класс `Money` (Работа с деньгами)

### Тест 1.1: Конструктор и нормализация копеек
**Описание:** Проверка автоматического перевода копеек в рубли, если их количество >= 100.
*   **Ввод:**
    *   Рубли: `5`
    *   Копейки: `150`
*   **Ожидаемый результат:**
    *   Вывод `ToString()`: `6 рублей и 50 копеек`

### Тест 1.2: Унарный инкремент (`++`)
**Описание:** Переход через границу рубля при добавлении копейки.
*   **Ввод:**
    *   Исходное значение: `0 рублей 99 копеек`
    *   Операция: `++`
*   **Ожидаемый результат:**
    *   `1 рублей и 0 копеек`

### Тест 1.3: Унарный декремент (`--`) с защитой от отрицательных значений
**Описание:** Попытка уменьшить нулевую сумму.
*   **Ввод:**
    *   Исходное значение: `0 рублей 0 копеек`
    *   Операция: `--`
*   **Ожидаемый результат:**
    *   `0 рублей и 0 копеек` (значение не изменилось)

### Тест 1.4: Сложение (`Money + Money`)
**Описание:** Сложение двух сумм с переполнением копеек.
*   **Ввод:**
    *   Сумма 1: `10 рублей 50 копеек`
    *   Сумма 2: `5 рублей 60 копеек`
*   **Ожидаемый результат:**
    *   `16 рублей и 10 копеек` (10+5=15р, 50+60=110к -> +1р 10к)

### Тест 1.5: Вычитание (`Money - uint`)
**Описание:** Вычитание целых рублей.
*   **Ввод:**
    *   Исходное значение: `10 рублей 50 копеек`
    *   Вычесть: `5` (рублей)
*   **Ожидаемый результат:**
    *   `5 рублей и 50 копеек`

### Тест 1.6: Вычитание с получением отрицательного результата
**Описание:** Вычитание большей суммы из меньшей.
*   **Ввод:**
    *   Уменьшаемое: `5 рублей 0 копеек`
    *   Вычитаемое: `10 рублей 0 копеек` (или объект `Money`)
*   **Ожидаемый результат:**
    *   `0 рублей и 0 копеек` (значение обнуляется, так как отрицательный баланс недопустим)

### Тест 1.7: Приведение типов
**Описание:** Явное и неявное приведение.
*   **Ввод:**
    *   Объект: `5 рублей 75 копеек`
*   **Ожидаемый результат:**
    *   `(uint)money`: `5`
    *   `(double)money`: `0.75`

---

## 2. Класс `ListAndHash` (Коллекции)

### Тест 2.1: `InsertAfterElement` (Список)
**Описание:** Вставка копии всего списка после первого вхождения заданного элемента.
*   **Ввод:**
    *   Список: `1, 2, 3`
    *   Элемент для вставки после: `2`
*   **Логика выполнения:**
    1. Итерация 1: Добавляем `1`. Рез: `[1]`
    2. Итерация 2: Добавляем `2`. Нашли `2`! Вставляем весь список `[1, 2, 3]`. Рез: `[1, 2, 1, 2, 3]`
    3. Итерация 3: Добавляем `3`. Рез: `[1, 2, 1, 2, 3, 3]`
*   **Ожидаемый результат:**
    *   `1, 2, 1, 2, 3, 3`

### Тест 2.2: `PrependAndAppend` (Связный список)
**Описание:** Добавление элемента в начало и конец.
*   **Ввод:**
    *   Список: `10, 20`
    *   Элемент: `5`
*   **Ожидаемый результат:**
    *   `5, 10, 20, 5`

### Тест 2.3: `AnalyzeBooks` (Множества)
**Описание:** Анализ читательских предпочтений.
*   **Ввод:**
    *   **Каталог библиотеки:** `HarryPotter, Hobbit, 1984, We`
    *   **Читатель 1:** `HarryPotter, Hobbit`
    *   **Читатель 2:** `HarryPotter, 1984`
    *   **Читатель 3:** `HarryPotter`
*   **Ожидаемый результат:**
    1.  **Прочли все читатели:** `HarryPotter` (есть у всех троих).
    2.  **Прочли некоторые (но не все):** `Hobbit` (только Ч1), `1984` (только Ч2).
    3.  **Не прочел никто:** `We` (есть в каталоге, но нет ни у кого).

### Тест 2.4: `FindSymbols` (Файл и символы)
**Описание:** Поиск символов, которых нет в первом слове, но есть во всех остальных.
*   **Ввод (содержимое файла `TextLab.txt`):**
    ```text
    apple apricot application
    ```
*   **Логика выполнения:**
    1.  **Слово 1 ("apple"):** Символы `{a, p, l, e}`.
    2.  **Слово 2 ("apricot"):** Символы `{a, p, r, i, c, o, t}`.
        *   Убираем символы первого слова (`a`, `p`).
        *   Остаток (кандидаты): `{r, i, c, o, t}`.
    3.  **Слово 3 ("application"):** Символы `{a, p, l, i, c, a, t, i, o, n}` -> `{a, p, l, i, c, t, o, n}`.
    4.  **Пересечение:** Берем кандидатов `{r, i, c, o, t}` и проверяем, есть ли они в слове 3.
        *   `r` -> нет в application. Удаляем.
        *   `i` -> есть.
        *   `c` -> есть.
        *   `o` -> есть.
        *   `t` -> есть.
*   **Ожидаемый результат:**
    *   Вывод символов: `i c o t` (порядок вывода может зависеть от реализации HashSet, но набор букв должен быть таким).
